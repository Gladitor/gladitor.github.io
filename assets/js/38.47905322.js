(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{409:function(e,a,t){"use strict";t.r(a);var n=t(2),l=Object(n.a)({},function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"c-datatable并发操作-索引超出了数组界限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#c-datatable并发操作-索引超出了数组界限","aria-hidden":"true"}},[e._v("#")]),e._v(" C# DataTable并发操作:索引超出了数组界限")]),e._v(" "),t("h2",{attrs:{id:"场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#场景","aria-hidden":"true"}},[e._v("#")]),e._v(" 场景")]),e._v(" "),t("p",[e._v("winform实现的OPC客户端，订阅数据更新时读取DataRow的数据不定时报出索引越界异常，debug模式下监控DataRow对象没有问题，对应索引列上有相应的值。现象非常离奇，异常不定时出现。订阅数据点量大，更新频率毫秒级，调试无法定位到具体原因。")]),e._v(" "),t("h2",{attrs:{id:"排查异常原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#排查异常原因","aria-hidden":"true"}},[e._v("#")]),e._v(" 排查异常原因")]),e._v(" "),t("p",[e._v("很容易就确认是多线程并发读写DataTable有问题，因此首先从DataTable的用法上查找原因。")]),e._v(" "),t("ul",[t("li",[e._v("DataTable多线程下使用"),t("br"),e._v("\n程序中多线程处理的地方已经加锁处理，开始以为时锁使用不当，查阅了大量相关资料以及回顾以往的使用经历发现DataTable的应用没有问题。贴出部分代码。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('lock (dt.Columns.SyncRoot)\n{\n   lock (dt.Rows.SyncRoot)\n    {\n        DataRow drTarget = dt.NewRow();\n        DataRow dr = null;\n        try\n        {\n            for (int i = 0; i < NumItems; i++)\n            {\n                for (int j = 0; j < itemDic.Count; j++)\n                {\n                    if (Convert.ToInt32(ClientHandles.GetValue(i + 1)) == Convert.ToInt32(itemDic.Keys.ToArray()[j]))\n                    {\n                        if (ItemValues.GetValue(i + 1) != null)\n                        {\n                            var clientHandle = ClientHandles.GetValue(i + 1);\n                            dr = dt.AsEnumerable().First(drtemp => { return drtemp["clientHandle"].ToString() == clientHandle.ToString(); });\n                            if (dr != null)\n                            {\n                                string drvalue_old = dr["itemValue"].ToString() == "" ? "0" : dr["itemValue"].ToString();\n                                string drvalue = ItemValues.GetValue(i + 1).ToString();\n                                DateTime drtimestamp = DateTime.Parse(TimeStamps.GetValue(i + 1).ToString());\n                                setCellValue(dr, "itemValue", ItemValues.GetValue(i + 1));\n                                setCellValue(dr, "itemQuality", Qualities.GetValue(i + 1));\n                                setCellValue(dr, "itemTimeStamp", drtimestamp);\n                                dataUpLoad(upstreamType, itemDic[clientHandle.ToString()], drvalue, drtimestamp.ToString());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }             \n}                                \n')])])]),t("ul",[t("li",[e._v("Code Review"),t("br"),e._v("\n没有办法，看着日志文件中的异常信息难受，决定从头走查一遍代码。终于发现了端倪，在DataRow对象写操作时采用了异步的方式，看到这时一下觉醒，这里异步就会有问题。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('void setCellValue(DataRow dr, string column, object value)\n{\n    try\n    {\n        if (value != null && value.Equals(""))\n        {\n            value = DBNull.Value;\n        }\n        if (this.InvokeRequired)\n        {\n            //this.BeginInvoke(new Action(() => { dr[column] = value; }));//1\n            this.Invoke(new Action(() => { dr[column] = value; }));//2\n        }\n        else\n            dr[column] = value;\n    }\n    catch (Exception ex)\n    {\n        MessageBox.Show(ex.Message + " | " + ex.StackTrace);\n    }\n}\n')])])]),t("p",[e._v("修改代码用2的方式，测试异常不再出现。上面代码执行委托时1是异步赋值，2是同步赋值，数据处理线程中DataTabel的操作是在锁下进行的，但1的方式委托给另外的线程进行DataRow的异步写操作，这时数据处理线程进行DataRow对象的读操作就可能有问题，所以这里并发出现问题。"),t("br"),e._v("\n查看以前数据采集工具中的用法也是用的第2种形式，所以没碰到该问题。")]),e._v(" "),t("ul",[t("li",[e._v("再次出现问题"),t("br"),e._v("\n生产环境中运行一段时间程序UI发生hang，这是因为生产环境数据量大UI线程堵塞了，于是还是要使用异步赋值。更改赋值核心代码解决问题。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (this.InvokeRequired)\n{\n    this.BeginInvoke(new Action(() => {\n        lock (dr.Table.Columns.SyncRoot)\n        {\n            lock (dr.Table.Rows.SyncRoot)\n            {\n                dr[column] = value;\n            }\n        }\n    }));\n}\n")])])]),t("h2",{attrs:{id:"结论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结论","aria-hidden":"true"}},[e._v("#")]),e._v(" 结论")]),e._v(" "),t("p",[e._v("Invoke和BeginInvoke是有很大区别的，使用锁的代码块内部进行委托操作时不要使用异步。如果必须使用异步并发操作对象就要加锁。开始我就是忽略了这一点，并不是DataTable的用法有问题。")]),e._v(" "),t("foot"),e._v(" "),t("Vssue",{attrs:{title:"dataTableIssue"}})],1)},[],!1,null,null,null);a.default=l.exports}}]);